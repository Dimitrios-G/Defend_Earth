<!DOCTYPE html>
<html lang="el">
<head>
    <meta charset="UTF-8">
    <title>Earth Defender - Final Version</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        body { margin: 0; background: #000; color: #0f6; font-family: 'Press Start 2P', cursive; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; touch-action: none; }
        #frame { width: 950px; height: 850px; border: 4px solid #0f6; position: relative; display: flex; flex-direction: column; background: #000; max-width: 100vw; max-height: 100vh; }
        .main-title { text-align: center; font-size: 18px; padding: 15px; border-bottom: 2px solid #0f6; }
        header { display: flex; gap: 10px; padding: 10px; font-size: 9px; justify-content: space-around; border-bottom: 2px solid #0f6; }
        .stat-item { border: 2px solid #0f6; padding: 8px; border-radius: 5px; }
        #uiLives { color: #ff0000; }
        #gamearea { flex: 1; position: relative; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
        footer { display: flex; justify-content: center; gap: 15px; padding: 10px; border-top: 4px solid #0f6; }
        .btn-retro { background: #000; color: #0f6; border: 2px solid #0f6; padding: 8px 12px; font-family: inherit; font-size: 9px; cursor: pointer; }
        .overlay { position: absolute; inset: 0; background: rgba(0,0,0,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 100; text-align: center; }
        input { background: #000; border: 2px solid #0f6; color: #0f6; padding: 10px; text-align: center; font-family: inherit; margin-bottom: 20px; outline: none; }
        .instructions { font-size: 10px; color: #0cf; margin-top: 20px; line-height: 1.6; }
    </style>
</head>
<body>

<div id="frame">
    <div class="main-title">üöÄ EARTH DEFENDER üöÄ</div>
    <header>
        <div class="stat-item">PILOT: <span id="uiName">---</span></div>
        <div class="stat-item">SCORE: <span id="uiScore">0</span></div>
        <div class="stat-item">LVL: <span id="uiLevel">1/40</span></div>
        <div class="stat-item">LIVES: <span id="uiLives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</span></div>
        <div class="stat-item">WEAPON: <span id="uiWeapon">SINGLE</span></div>
    </header>
    
    <div id="gamearea">
        <canvas id="gameCanvas" width="950" height="600"></canvas>
        <div id="menu" class="overlay">
            <input type="text" id="nameInput" placeholder="ENTER NAME" maxlength="10">
            <button class="btn-retro" onclick="startGame()">LAUNCH MISSION</button>
            <div class="instructions">
                --- CONTROLS ---<br>
                ARROWS / TOUCH: MOVE SHIP<br>
                SPACE / AUTO: FIRE WEAPON<br>
                P: POWER-UPS | S: SHIELD
            </div>
        </div>
        <div id="gameOver" class="overlay" style="display:none">
            <h1 id="endStatus" style="color:#f00">GAME OVER</h1>
            <div id="hsList" style="font-size: 10px; line-height: 1.8; margin-bottom: 20px;"></div>
            <button class="btn-retro" onclick="location.reload()">RESTART</button>
            <button class="btn-retro" onclick="clearHS()" style="color:#f00; border-color:#f00; margin-top:10px;">CLEAR HIGH SCORES</button>
        </div>
    </div>

    <footer>
        <button class="btn-retro" onclick="isPaused = !isPaused">PAUSE</button>
        <button class="btn-retro" onclick="window.close()">QUIT</button>
    </footer>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

let isPaused = false, warping = false;
let state = {
    active: false, score: 0, level: 1, lives: 3, weapon: 0,
    enemiesRemaining: 0, shield: 0, bossSpawned: false,
    player: { x: 450, y: 500 },
    bullets: [], enemyBullets: [], enemies: [], particles: [], powerups: [], stars: [], keys: {}
};

for(let i=0; i<80; i++) state.stars.push({x: Math.random()*950, y: Math.random()*600, s: Math.random()*3+1});

window.onkeydown = e => state.keys[e.code] = true;
window.onkeyup = e => state.keys[e.code] = false;

// TOUCH MOVEMENT LOGIC
canvas.addEventListener('touchmove', e => {
    if(!state.active || isPaused) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    state.player.x = (touch.clientX - rect.left) * scaleX - 20;
    state.player.y = (touch.clientY - rect.top) * scaleY - 30;
}, { passive: false });

// --- ŒóŒßŒüŒô & ŒúŒüŒ•Œ£ŒôŒöŒó ---
function playShootSound() {
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.type = 'triangle'; osc.frequency.setValueAtTime(400, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1);
    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.1);
}

function playExplodeSound() {
    const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
    osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + 0.3);
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
    osc.connect(gain); gain.connect(audioCtx.destination);
    osc.start(); osc.stop(audioCtx.currentTime + 0.3);
}

function startMusic() {
    const notes = [110, 123, 130, 146, 110, 123, 164, 146];
    let step = 0;
    function playStep() {
        if (!state.active) return;
        if (!isPaused) {
            const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain();
            osc.type = 'sine'; osc.frequency.setValueAtTime(notes[step % notes.length], audioCtx.currentTime);
            gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);
            osc.connect(gain); gain.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + 0.5);
            step++;
        }
        setTimeout(playStep, 400);
    }
    playStep();
}

function createExplosion(x, y, color, count = 25) {
    playExplodeSound();
    for(let i=0; i<count; i++) {
        state.particles.push({ x: x, y: y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12, life: 40, color: color });
    }
}

function startGame() {
    document.getElementById('uiName').innerText = document.getElementById('nameInput').value || "Pilot";
    document.getElementById('menu').style.display = 'none';
    state.active = true;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    startMusic();
    startLevel();
    loop();
}

function startLevel() {
    warping = false; state.bossSpawned = false; state.enemies = []; state.enemyBullets = [];
    state.player.y = 500;
    state.enemiesRemaining = 5 + (state.level * 2);
    if(state.level % 5 === 0) state.enemiesRemaining = 1;
}

function fire() {
    const p = state.player; playShootSound();
    if(state.weapon === 0) state.bullets.push({x: p.x+18, y: p.y, vy: -12});
    else if(state.weapon === 1) state.bullets.push({x: p.x+5, y: p.y, vy: -12}, {x: p.x+32, y: p.y, vy: -12});
    else if(state.weapon === 2) state.bullets.push({x: p.x+18, y: p.y, vy: -12}, {x: p.x, y: p.y+10, vy: -10, vx:-2}, {x: p.x+36, y: p.y+10, vy: -10, vx:2});
    else state.bullets.push({x: p.x+18, y: p.y, vy: -20, laser: true});
}

function update() {
    if(!state.active || isPaused) return;
    if(warping) {
        state.player.y -= 15;
        if(state.player.y < -100) { if(state.level >= 40) { winGame(); return; } state.level++; startLevel(); }
        return;
    }
    
    // Keyboard Movement
    if(state.keys['ArrowLeft'] && state.player.x > 0) state.player.x -= 7;
    if(state.keys['ArrowRight'] && state.player.x < 910) state.player.x += 7;
    if(state.keys['ArrowUp'] && state.player.y > 0) state.player.y -= 7;
    if(state.keys['ArrowDown'] && state.player.y < 540) state.player.y += 7;
    
    // Auto-fire or Space
    if((state.keys['Space'] || 'ontouchstart' in window) && Date.now() - (state.lastFire || 0) > 180) { 
        fire(); state.lastFire = Date.now(); 
    }
    
    if(state.shield > 0) state.shield--;

    if(state.level % 5 === 0) {
        if(!state.bossSpawned && state.enemies.length === 0) {
            state.enemies.push({ x: 350, y: -150, s: 2, hp: state.level * 15, mhp: state.level * 15, boss: true, d: 1 });
            state.bossSpawned = true;
        }
    } else {
        if(state.enemiesRemaining > state.enemies.length && state.enemies.length < 6) {
            if(Math.random() < 0.04) state.enemies.push({ x: Math.random()*850, y: -50, s: 2+(state.level*0.2), hp: 1, boss: false });
        }
    }

    state.enemies.forEach((en, i) => {
        if(en.boss) {
            if(en.y < 60) en.y += 1; en.x += (3 + (state.level/10)) * en.d;
            if(en.x > 700 || en.x < 0) en.d *= -1;
            if(Math.random() < 0.05) state.enemyBullets.push({x: en.x+125, y: en.y+80, vy: 5+(state.level/10)});
            if(state.level >= 10 && Math.random() < 0.03) state.enemies.push({ x: en.x + 100, y: en.y + 100, s: 4, hp: 1, boss: false, isMinion: true });
        } else {
            en.y += en.s; if(en.y > 600) { if(en.isMinion) state.enemies.splice(i, 1); else { en.y = -50; en.x = Math.random()*850; } }
        }
        let dist = en.boss ? 80 : 35;
        if(Math.abs(en.x+(en.boss?125:20)-(state.player.x+20)) < dist && Math.abs(en.y+(en.boss?50:20)-(state.player.y+30)) < dist) {
            if(state.shield <= 0) { state.lives--; createExplosion(state.player.x+20, state.player.y+30, '#f00', 50); if(state.lives <= 0) endGame(); state.shield = 100; }
        }
    });

    state.bullets.forEach((b, bi) => {
        b.y += b.vy; b.x += (b.vx || 0);
        state.enemies.forEach((en, ei) => {
            let hit = b.x > en.x && b.x < en.x+(en.boss?250:40) && b.y < en.y+(en.boss?100:30);
            if(hit) {
                en.hp--; if(!b.laser) state.bullets.splice(bi, 1);
                if(en.hp <= 0) {
                    createExplosion(en.x+(en.boss?125:20), en.y+(en.boss?50:15), en.boss?'#f0f':'#0f6');
                    state.score += en.boss ? 2000 : 100;
                    if(Math.random() < 0.08) state.powerups.push({x: en.x, y: en.y, t: Math.random() < 0.7 ? 'P' : 'S'});
                    state.enemies.splice(ei, 1); if(!en.isMinion) state.enemiesRemaining--;
                }
            }
        });
        if(b.y < -50) state.bullets.splice(bi, 1);
    });

    state.enemyBullets.forEach((eb, ebi) => {
        eb.y += eb.vy;
        if(Math.abs(eb.x - (state.player.x+20)) < 25 && Math.abs(eb.y - (state.player.y+30)) < 25) {
            if(state.shield <= 0) { state.lives--; createExplosion(state.player.x+20, state.player.y+30, '#f00', 40); if(state.lives <= 0) endGame(); state.shield = 100; }
            state.enemyBullets.splice(ebi, 1);
        }
        if(eb.y > 650) state.enemyBullets.splice(ebi, 1);
    });

    state.powerups.forEach((p, i) => {
        p.y += 3;
        if(Math.abs(p.x - state.player.x) < 50 && Math.abs(p.y - state.player.y) < 50) {
            if(p.t === 'P') state.weapon = Math.min(state.weapon+1, 3); else state.shield = 400;
            state.powerups.splice(i, 1);
        }
    });

    state.particles.forEach((p, i) => { p.x += p.vx; p.y += p.vy; p.life--; if(p.life <= 0) state.particles.splice(i, 1); });
    if(state.enemiesRemaining <= 0 && state.enemies.length === 0 && !warping) warping = true;
    state.stars.forEach(s => { s.y += warping ? 20 : s.s; if(s.y > 600) s.y = 0; });
    updateUI();
}

function updateUI() {
    document.getElementById('uiScore').innerText = state.score;
    document.getElementById('uiLevel').innerText = state.level + "/40";
    document.getElementById('uiLives').innerText = "‚ù§Ô∏è".repeat(Math.max(0, state.lives));
    document.getElementById('uiWeapon').innerText = ["SINGLE", "DOUBLE", "TRIPLE", "LASER"][state.weapon];
}

function draw() {
    ctx.fillStyle = '#000'; ctx.fillRect(0,0,950,600);
    ctx.fillStyle = '#fff'; state.stars.forEach(s => ctx.fillRect(s.x, s.y, 2, 2));
    if(state.shield > 0) { ctx.strokeStyle = '#0cf'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(state.player.x+20, state.player.y+30, 45, 0, Math.PI*2); ctx.stroke(); }
    ctx.fillStyle = '#0f6'; ctx.beginPath(); ctx.moveTo(state.player.x+20, state.player.y); ctx.lineTo(state.player.x+40, state.player.y+45); ctx.lineTo(state.player.x+30, state.player.y+38); ctx.lineTo(state.player.x+10, state.player.y+38); ctx.lineTo(state.player.x, state.player.y+45); ctx.fill();
    ctx.fillStyle = Math.random() > 0.5 ? '#f60' : '#ff0'; ctx.fillRect(state.player.x+16, state.player.y+40, 8, warping?30:12);
    state.enemies.forEach(en => {
        ctx.fillStyle = en.boss ? '#f0f' : '#f04'; ctx.beginPath(); ctx.ellipse(en.x+(en.boss?125:20), en.y+(en.boss?50:15), en.boss?120:20, en.boss?40:10, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#0ff'; ctx.beginPath(); ctx.arc(en.x+(en.boss?125:20), en.y+(en.boss?40:10), en.boss?40:10, 0, Math.PI, true); ctx.fill();
        if(en.boss) { ctx.fillStyle = '#fff'; ctx.fillRect(en.x, en.y-20, (en.hp/en.mhp)*250, 8); }
    });
    state.enemyBullets.forEach(eb => { ctx.fillStyle = '#ff0'; ctx.beginPath(); ctx.arc(eb.x, eb.y, 5, 0, Math.PI*2); ctx.fill(); });
    state.powerups.forEach(p => { ctx.fillStyle = p.t==='P' ? '#ff0' : '#0cf'; ctx.fillRect(p.x, p.y, 35, 35); ctx.fillStyle = '#000'; ctx.font = 'bold 20px Arial'; ctx.fillText(p.t, p.x+10, p.y+26); });
    state.bullets.forEach(b => { ctx.fillStyle = b.laser ? '#0ff' : '#fff'; ctx.fillRect(b.x, b.y, b.laser?8:4, b.laser?40:15); });
    state.particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life / 40; ctx.fillRect(p.x, p.y, 3, 3); });
    ctx.globalAlpha = 1;
}

function endGame() { state.active = false; saveHS(); document.getElementById('gameOver').style.display = 'flex'; }
function winGame() { state.active = false; document.getElementById('endStatus').innerText = "VICTORY!"; saveHS(); document.getElementById('gameOver').style.display = 'flex'; }
function saveHS() {
    let hs = JSON.parse(localStorage.getItem("hs")||"[]"); hs.push({n: document.getElementById('uiName').innerText, s: state.score});
    hs.sort((a,b)=>b.s-a.s); hs = hs.slice(0,5); localStorage.setItem("hs", JSON.stringify(hs)); renderHS(hs);
}
function renderHS(list) { document.getElementById('hsList').innerHTML = "TOP SCORES:<br>" + list.map(i=>`${i.n}: ${i.s}`).join("<br>"); }
function clearHS() { localStorage.removeItem("hs"); renderHS([]); }
function loop() { update(); draw(); if(state.active) requestAnimationFrame(loop); }
</script>
</body>
</html>
